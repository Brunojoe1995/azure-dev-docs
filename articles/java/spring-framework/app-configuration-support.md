---
title: Developers Guide for Using Spring Cloud Azure App Configuration Config | Microsoft Docs
description: This developer guide walks you through using Spring Cloud Azure App Configuration Config.
services: azure-app-configuration
documentationcenter: ''
author: mrm9084
manager: zhenlan
editor: ''

ms.assetid: 
ms.service: azure-app-configuration
ms.workload: tbd
ms.devlang: java
ms.topic: tutorial
ms.date: 03/31/2023
ms.author: mametcal
ms.custom: mvc, devx-track-java

#Customer intent: As a developer, I want to use Spring Cloud Azure App Configuration Config to load configurations from Azure App Configuration.
---

# App Configuration Support

Spring is an open-source application framework developed by VMware that provides a simplified, modular approach for creating Java applications. Spring Cloud Azure is an open-source project that provides seamless Spring integration with Azure services.

The Azure Spring Cloud App Configuration Client Library loads configurations and feature flags from the [Azure App Configuration service](/azure/azure-app-configuration/index). The client library generates `PropertySource` abstractions, to match those already being generated by the Spring environment such as; environment variables, command-line configurations, local configuration files, and so on.

## Setting up your App Configuration store

### Prerequisites

- An Azure subscription - [create one for free](https://azure.microsoft.com/free).
- [Java Development Kit (JDK)](/java/azure/jdk/) version 8 or higher.
- [Apache Maven](https://maven.apache.org)
- [Azure CLI](/cli/azure/install-azure-cli)

To create your Azure App Configuration store, you can use:

```azurecli
az appconfig create --resource-group <your-resource-group> --name <name-of-your-new-store> --sku Standard
```

This command creates a new empty configuration store. You can upload your configurations using the import command:

```azurecli
az appconfig kv import -n <name-of-your-new-store> -s file --path <location-of-your-properties-file> --format properties --prefix /application/
```

Confirm your configurations before loading them. You can upload yaml files by changing the format to yaml. The prefix field is important as it's the default prefix loaded by the client library.

## Client usage

To use the feature in an application, you can build it as a Spring Boot application. The most convenient way to add the dependency is with our Spring Boot starter `com.azure.spring:spring-cloud-azure-starter-appconfiguration-config`. The following example `pom.xml` file uses Azure App Configuration:

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>{spring-boot-version}</version>
    <relativePath />
</parent>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>{spring-cloud-version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>com.azure.spring</groupId>
        <artifactId>spring-cloud-azure-starter-appconfiguration-config</artifactId>
        <version>{azure-appconfiguration-version}</version>
    </dependency>
</dependencies>
<build>
    <plugins>
           <plugin>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-maven-plugin</artifactId>
           </plugin>
    </plugins>
</build>
```

A basic Spring Boot application using App Configuration:

```java
@SpringBootApplication
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

with `bootstrap.properties` containing:

```properties
spring.cloud.azure.appconfiguration.stores[0].connection-string=${CONFIG_STORE_CONNECTION_STRING}
```

where `CONFIG_STORE_CONNECTION_STRING` is an environment variable with the connection string to your Azure App Configuration Store. You can access your connection string by running:

```azurecli
az appconfig credential list --name <name-of-your-store>
```

By default, if no configurations are set, then the configurations starting with `/application/` are loaded with a default label of `(No Label)` unless a Spring Profile is set in which case the default label is your Spring Profile. Because the store is empty no configurations are loaded, but the Azure App Configuration Property Source is still generated.

A property source named `/application/https://<name-of-your-store>.azconfig.io/` is created containing the properties of that store. The label used in the request is appended to the end of the name. If no label is set the character `\0` is there, as an empty space.

## Loading configuration

The library supports the loading of one or multiple App Configuration stores. In the situation where a key is duplicated across multiple stores, loading all stores results in the highest priority, last one wins, stores configuration being loaded. Example:

```properties
spring.cloud.azure.appconfiguration.stores[0].connection-string=[first-store-connection-string]
spring.cloud.azure.appconfiguration.stores[1].connection-string=[second-store-connection-string]
```

In the example, if both the first and second stores have the same configuration, the configuration in the second store has the highest priority, last one wins.

> [!NOTE]
> Azure App Configuration settings can be used like any other Spring Configuration. See [Spring Boot Docs](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html) or [Azure App Configuration QuickStart](/azure/azure-app-configuration/quickstart-java-spring-app).

### Selecting configurations

Configurations are loaded by their key and label. By default, the configurations that start with the key `/application/` are loaded. The default label is `${spring.profiles.active}`. If `${spring.profiles.active}` isn't set, then configuration with the null label seen as `(No Label)` in the portal are loaded.

The configurations that are loaded can be configured by selecting different key and label filters.

```properties
spring.cloud.azure.appconfiguration.stores[0].selects[0].key-filter=[my-key]
spring.cloud.azure.appconfiguration.stores[0].selects[0].label-filter=[my-label]
```

`key-filter` supports the following filters:

| Key Filter | Effect |
| --- | --- |
| `*` | Matches **any** key |
| `abc` | Matches a key named  **abc** |
| `abc*` | Matches key names that start with **abc** |
| `abc,xyz` | Matches key names **abc** or **xyz** (limited to 5 CSV) |

`label-filter` supports the following filters:

| Label | Description |
| --- | --- |
| `*` |Matches **any** label, which includes `\0` |
| `\0` |Matches `null` labels, seen as `(No Label)` in the portal |
| `1.0.0` | Matches label **1.0.0** exactly |
| `1.0.*` | Matches labels that start with **1.0.** |
| `,1.0.0` |Matches labels `null` or **1.0.0**, limited to five CSVs |

If you're using yaml with label filters and need to start with `null`, then the label filter needs to be surrounded by single quotes.

```yml
spring:
  cloud:
    azure:
      appconfiguration:
        stores:
        - selects:
          - label-filter: ',1.0.0'
```

> [!NOTE]
> You're unable to combine `*` with `,` in filters. In that case you need to use an additional select.

### Spring Profiles

By default, `spring.profiles.active` is set as the default `label-filter` for all selected configurations. This functionality can be overridden by the `label-filter`. The Spring Profiles can be used in the `label-filter` by using `${spring.profiles.active}` in the `label-filter`.

```properties
spring.cloud.azure.appconfiguration.stores[0].selects[0].label-filter=,${spring.profiles.active}
spring.cloud.azure.appconfiguration.stores[0].selects[1].label-filter=${spring.profiles.active}_local
```

In the first `label-filter`, all configurations with `null` label are loaded, followed by all configurations matching the Spring Profiles. Spring Profiles have priority over the `null` configurations, because they're at the end.

In the second `label-filter`, the string `_local` is appended to the end of the Spring Profiles, though only to the last Spring Profile.

### Disabled stores

Using the configuration `spring.cloud.azure.appconfiguration.enabled` you can disable loading all configuration stores. With the `spring.cloud.azure.appconfiguration.stores[0].enabled` configuration, you can disable an individual store.

In addition to disabling stores, stores can be configured to be disabled if they fail to load using the `spring.cloud.azure.appconfiguration.stores[0].fail-fast`. When `fail-fast` is disabled, set to `false`, a `RuntimeException` will result in the application the store being disabled with no configurations from it loaded. If a configuration store is disabled on startup it will not be checked for changes with refresh, or attempted to be loaded from if configurations are updated.

If an error resulting in a `RuntimeException` happens during a refresh check or while attempting to reload configurations, then the refresh attempt will be ended and will be retried after the `refresh-interval` has passed.

## Authentication

The client library supports all forms of identity supported by the [Azure Identity Library](https://github.com/Azure/azure-sdk-for-java/tree/main/sdk/identity/azure-identity). Authentication can be done through configuration for connection strings and managed identity. All other forms of identity can be done by using the `TokenCredentialProvider`.

### Connection string

Authentication through connection string is the simplest form to set up. You can access a store's connection strings using:

```azurecli
az appconfig credential list --name <name-of-your-store>
```

The connection string can then be set to the property `spring.cloud.azure.appconfiguration.stores[0].connection-string`. It's highly recommended that the connection string in the local configuration file should be a placeholder value, which should map to an environment variable to avoid having it added to source control.

### Spring Cloud Azure configuration

[Spring Cloud Azure configuration](/azure/developer/java/spring-framework/configuration) can be used to configure the client library. The following properties can be used to configure the client library:

```properties
spring.cloud.azure.appconfiguration.stores[0].endpoint= <URI of your Configuration store>
```

When only the endpoint is set, the client library uses the [`DefaultAzureCredential`](https://github.com/Azure/azure-sdk-for-java/tree/main/sdk/identity/azure-identity#credential-classes) to authenticate. The `DefaultAzureCredential` uses the following methods to authenticate:

- Environment credential
- Managed Identity credential
- Azure Developer CLI credential
- IntelliJ credential
- Azure CLI credential
- Azure PowerShell credential

You need to assign an identity such as a system assigned identity to read configurations.

```azurecli
az role assignment  create --role "App Configuration Data Reader" --assignee <your client id> --scope /subscriptions/<your subscription>/resourceGroups/<your stores resource group>/providers/Microsoft.AppConfiguration/configurationStores/<name of your Configuration Store>
```

> [!NOTE]
> Only 1 authentication method can be defined per endpoint: connection string, user assigned identity, or token credential. If you need to mix and match you can use `ConfigurationClientCustomizer` to modify stores that use a different method.

## Geo-replication

The library supports the geo-replication feature of Azure App Configuration. This feature allows you to replicate your data to additional location(s). This feature is useful for high availability and disaster recovery.

Each replica you create has its dedicated endpoint. If your application resides in multiple geolocations, you can update each deployment of your application in a location to connect to the replica closer to that location, which helps minimize the network latency between your application and App Configuration. Since each replica has its separate request quota, this setup also helps the scalability of your application while it grows to a multi-region distributed service.

The failover may occur if the library observes any of the following conditions:

- Receives responses with service unavailable status code (HTTP 500 or above) from an endpoint.
- Experiences with network connectivity issues.
- Requests are throttled (HTTP status code 429)

### Creating a configuration store with geo-replication

To create a replica of your configuration store, you can use the Azure CLI or the Azure portal. The following example uses the Azure CLI to create a replica in the East US 2 region.

```azurecli
az appconfig replica create --location --name --store-name [--resource-group]
```

### Using the configuration store replica

Once you've created a replica, you can use it in your application. Like the origin store, you can connect to your replica using Azure Active Directory (Azure AD) or a connection string.

**Using Azure AD**

To use Azure AD to connect to your replica, you need to list the `endpoints` of your configuration store instances.

```properties
spring.cloud.azure.appconfiguration.stores[0].endpoints[0]=[your primary store endpoint]
spring.cloud.azure.appconfiguration.stores[0].endpoints[1]=[your replica store endpoint]
```

You can list as many endpoints as you have replicas. The library tries to connect to the endpoints in the order they're listed. If the library is unable to connect to a replica, it will try the next one in the list. After a period of time has passed, the library will attempt to reconnect to the preferred endpoints.

**Using a Connection String**

To use a connection string to connect to your replica, you need to list the `connectionStrings` of your configuration store instances.

```properties
spring.cloud.azure.appconfiguration.stores[0].connectionStrings[0]=[your primary store connection string]
spring.cloud.azure.appconfiguration.stores[0].connectionStrings[1]=[your replica store connection string]
```

You can list as many connection strings as you have replicas. The library tries to connect to the connection strings in the order they're listed. If the library is unable to connect to a replica, it will try the next one in the list. After a period of time has passed, the library will attempt to reconnect to the preferred connection strings.

## Key values

Azure App Configuration supports multiple types of key values, some of which have special features built into them. Azure App Configuration has built in support for the JSON content type, Spring placeholders, and Key Vault references.

### Placeholders

The client library supports configurations with `${}`-style environment placeholders. When referencing an Azure App Configuration key with a placeholder, remove prefixes from the reference. For example: `/application/config.message` is referenced as `${config.message}`.

> [!NOTE]
> The prefix being removed matches the value `spring.cloud.azure.appconfiguration.stores[0].selects[0].key-filter`.

### JSON

Configurations that have a content-type `application/json` are processed as JSON objects. This let you map one configuration mapping to a complex objects inside of `@ConfigurationProperties`. For example, the JSON key `/application/config.colors` with the value

```json
{
 "Red": {
  "value": [255, 0, 0]
 },
 "Blue": {
  "value": [0, 255, 0]
 },
 "Green": {
  "value": [0, 0, 255]
 }
}
```

maps to

```java
@ConfigurationProperties(prefix = "config")
public class MyConfigurations {

    private HashMap<String, Color> colors;

}
```

### Key Vault references

Azure App Configuration and its client libraries support referencing secrets stored in Key Vault. In App Configuration, keys can be created with values that map to a secret stored in a Key Vault. Secrets are securely stored in Key Vault, but can be accessed in the same way as any other configuration once loaded.

Your application uses the client provider to retrieve Key Vault references, just as it does for any other keys stored in App Configuration. Because the client recognizes the keys as Key Vault references, they have a unique content-type, and the client connects to Key Vault to retrieve their values for you.

> [!NOTE]
> Key Vault only allows for secrets to be retrieved one at a time, so each Key Vault reference stored in App Configuration will result in a pull against Key Vault.

#### Creating Key Vault references

You can create a Key Vault reference in the Azure portal by goint to **Configuration explorer** > **Create** > **Key Vault reference**. You can then select a secret to reference from any of the Key Vaults you have access to. You can also create arbitrary Key Vault references from the **Input** tab. In the Azure portal, enter a valid URI.

You can also create a Key Vault reference through the CLI using:

```azurecli
az appconfig kv set-keyvault --name <name-of-your-store> --key <key-name> --secret-identifier <uri-to-your-secret>
```

Though the CLI any secret-identifier can be created, they just require the format `{vault}/{collection}/{name}/{version?}` where the version section is optional.

#### Using Key Vault references

[Spring Cloud Azure configuration](/azure/developer/java/spring-framework/configuration) can be used to configure the client library. The same credential used to connect to App Configuration can be used to connect to Azure Key Vault.

#### Resolve non-Key Vault secrets

The App Configuration client provides a method to locally resolve secrets that don't have a Key Vault associated with them. This is done through the `KeyVaultSecretProvider`. The `KeyVaultSecretProvider` is called when a `TokenCredential` isn't provided for a Key Vault reference. The URI of the Key Vault reference is provided and the returned value becomes the value of the secret.

> [!WARNING]
> The use of a `KeyVaultSecretProvider` overrides the automatic use of the system-assigned managed identity. To use both, `KeyVaultCredentialProvider` needs to be used and return `null` for the URIs that need resolving.

```java
public class MySecretProvider implements KeyVaultSecretProvider {

    @Override
    public String getSecret(String uri) {
        ...
    }

}
```

## Feature management

Feature management provides a way for Spring Boot applications to dynamically access content. Feature management has a variety of functions, such as feature flags that can enable or disable content, feature filters for targeting when content is shown, customized feature filters, and feature gates for dynamically enabling endpoints.

Feature flag can be enabled through the following configuration:

```properties
spring.cloud.azure.appconfiguration.stores[0].feature-flags.enabled= true
```

Enabled feature flags are loaded into the Spring configuration system with the prefix `feature-management`. Feature flags can also be registered in the local configuration file, see [Feature flag declaration](#feature-flag-declaration). The easiest way to use feature management is by using the `spring-cloud-azure-feature-management` and `spring-cloud-azure-feature-management-web` libraries. The difference between the two libraries is that `spring-cloud-azure-feature-management-web` takes a dependency on the `spring-web` and `spring-webmvc` libraries to add additional features, such as [feature gates](#routing).

Feature flags can be loaded by key/label filters. By default, a null label, seen as `(No Label)` is assigned. The feature flags that are loaded can be configured by setting a label filter:

```properties
spring.cloud.azure.appconfiguration.stores[0].feature-flags.selects[0].key-filter=A*
spring.cloud.azure.appconfiguration.stores[0].feature-flags.selects[0].label-filter= dev
```

### Feature management basics

#### Feature flags

Feature flags are composed of two parts, a name and a list of feature-filters that are used to turn on the feature. Feature flags can either have a boolean state of on/off, or they can have a list of feature filters. Feature flags evaluate feature filters until one returns true. If no feature filter returns true, then the feature flag returns false.

#### Feature filters

Feature Filters define a scenario for when a feature should be enabled. Feature Filters are evaluated synchronously.

The Feature Management library comes with four predefined filters: [AlwaysOnFilter](#alwaysonfilter), [PercentageFilter](#percentagefilter), [TimeWindowFilter](#timewindowfilter), [TargetingFilter](#targetingfilter).

Custom Feature Filters be made. For example, a Feature Filter could be used to provide a custom experience for only the customers who are using a Microsoft Edge browser. The features in this Feature Filter can be customized, for example to show a specific header for the Microsoft Edge browser audience.

#### Feature Flag Declaration

The Feature Management library supports Azure App Configuration along with application.yml or bootstrap.yml as sources for Feature Flags. Here's an example of the format used to set up Feature Flags in a application.yml file.

```yaml
feature-management:
  feature-t: false
  feature-u:
    enabled-for:
    - name: Random
  feature-v:
    enabled-for:
    - name: TimeWindowFilter
      parameters:
        Start: "Wed, 01 May 2019 13:59:59 GMT"
        End: "Mon, 01 July 2019 00:00:00 GMT"
  feature-w:
    evaluate: false
    enabled-for:
    - name: AlwaysOnFilter
```

- `feature-t` is set to false, this setting always return the Feature Flag's value.
- `feature-u` is used with Feature Filters. These Filters are defined under the `enabled-for` property.  In this case, `feature-u` has one Feature Filter called `Random`, which doesn't require any configuration, so only the name property is required.
- `feature-v` specifies a Feature Filter named `TimeWindowFilter`. This Feature Filter can be passed parameters to use as configuration. In this case, a `TimeWindowFilter`, pass in the start and end times for which the feature will be active.
- `feature-w` is used for the `AlwaysOnFilter`, which always evaluates to `true`. The `evaluate` field is used to stop the evaluation of the Feature Filters, and results in the Feature Filter always return `false`.

### Evaluating Feature Flags

`spring-cloud-azure-feature-management` library provides `FeatureManager` to check if a Feature Flag is enabled. It provides an asynchronous way to check the state of the flag.

`spring-cloud-azure-feature-management-web` along with providing `FeatureManager` has `FeatureManagerSnapshot`, which caches the state of previously evaluated Feature Flags in the `@RequestScope` to guarantee all requests return the same value. In addition, the web library provides `@FeatureGate`, which can either block or redirect web requests to different endpoints.

#### Feature Flag Check

`FeatureManager` is a `@Bean` that can be `@Autowired` or injected into `@Component` type objects. `FeatureManager` has a method `isEnabled` that, when passed the name of a Feature Flag, returns its state.

```java
@Autowired
FeatureManager featureManager;

if(featureManager.isEnabled("feature-t")) {
    // Do Something
}
```

> [!NOTE]
> `FeatureManger` also has an asynchronous version of `isEnabled` called `isEnabledAsync`.

If Feature Management hasn't been configured or the Feature Flag doesn't exist, `isEnabled` always return false. If an existing Feature Flag is configured with an unknown Feature Filter, then a `FilterNotFoundException` is thrown. This can be changed to return false by configuring `fail-fast` to false.

| Name | Description | Required | Default |
| --- | --- | --- | --- |
|spring.cloud.azure.feature.management.fail-fast | If an exception occurs, a RuntimeException is thrown, if set to false then returns false instead. | No |  true |

`FeatureManagerSnapshot` works the same as `FeatureManager`, besides its caching of results in the `@RequestScope`.

#### Feature Gate

With the Feature Management Web library, you can require that a given feature is enabled in order to execute an endpoint. This can be done by using the `@FeatureGate` annotation.

```java
@GetMapping("/featureT")
@FeatureGate(feature = "feature-t")
@ResponseBody
public String featureT() {
    ...
}
```

The `featureT` endpoint can only be accessed if "feature-t" is enabled.

##### Disabled Action Handling

When an endpoint is blocked because the feature it specifies is disabled, `DisabledFeaturesHandler` is invoked. By default, an HTTP 404 is returned. This can be overridden by implementing `DisabledFeaturesHandler`.

```java
@Component
public class MyDisabledFeaturesHandler implements DisabledFeaturesHandler {

    @Override
    public HttpServletResponse handleDisabledFeatures(HttpServletRequest request, HttpServletResponse response) {
        ...
        return response;
    }

}
```

##### Routing

Certain routes may expose application capabilities that are gated by features. These routes can be redirected to another endpoint if a feature has been disabled.

```java
@GetMapping("/featureT")
@FeatureGate(feature = "feature-t" fallback= "/oldEndpoint")
@ResponseBody
public String featureT() {
    ...
}

@GetMapping("/oldEndpoint")
@ResponseBody
public String oldEndpoint() {
    ...
}
```

### Built-In Feature Filters

There are a few Feature Filters that come with the `spring-cloud-azure-feature-management` package. These Feature Filters aren't added automatically, but can be set up in an `@Configuration` for use.

#### AlwaysOnFilter

This filter always returns true. Usage can be see in the [Feature Flag Declaration](#feature-flag-declaration).

#### PercentageFilter

Each evaluation of `PercentageFilter` can return a different result, which aren't consistent among one user's requests. This can be circumvented using the `FeatureManagementSnapshot`, which caches the result of the Feature Flag per user. This ensures a User has a consistent experience even if they have to resend the request.

```yaml
feature-management:
  feature-v:
    enabled-for:
    - name: PercentageFilter
      parameters:
        Value: 50
```

#### TimeWindowFilter

This filter provides the capability to enable a feature based on a time window. If only `End` is specified, the feature is considered on until that time. If only start is specified, the feature is considered on at all points after that time. If, both are specified the feature is considered valid between the two times.

```yaml
feature-management:
  feature-v:
    enabled-for:
    - name: TimeWindowFilter
      parameters:
        Start: "Wed, 01 May 2019 13:59:59 GMT",
        End: "Mon, 01 July 2019 00:00:00 GMT"
```

#### TargetingFilter

This filter provides the capability to enable a feature for a target audience. An in-depth explanation of targeting is explained in the [targeting section](#targeting). The filter parameters include an audience object that describes users, groups, and a default percentage of the user base that should have access to the feature. For each group object that is listed in the target audience, a percentage is required which defines the percentage of that group's members, which have access to the feature. If a user is specified in the users' section directly, or if the user is in the included percentage of any of the group rollouts, or if the user falls into the default rollout percentage, then that user has the feature enabled.

```yaml
feature-management: 
  target:
    enabled-for:
    - name: targetingFilter
      parameters:
        users:
        - Jeff
        - Alicia
        groups:
        - name: Ring0
          rollout-percentage: 100
        - name: Ring1
          rolloutPercentage: 100
        default-rollout-percentage: 50
```

### Custom Feature Filters

Creating a custom Feature Filter provides a way to enable features based on criteria that you define. To create a custom Feature Filter, the `FeatureFilter` interface must be implemented. `FeatureFilter` has a single method `evaluate`. When a feature specifies that it can be enabled with a Feature Filter, the `evaluate` method is called. If, `evaluate` returns `true` it means the feature should be enabled. If `false` it continues evaluating the Feature's filters until one returns true. If all return `false` then the feature is off.

Feature Filters are found by being defined as being Spring Beans, so they're either defined as `@Component` or defined in an `@Configuration`.

```java
@Component("Random")
public class Random implements FeatureFilter {

    @Override
    public boolean evaluate(FeatureFilterEvaluationContext context) {
        double chance = Double.valueOf((String) context.getParameters().get("chance"));
        return Math.random() > chance / 100;
    }

}
```

#### Parameterized Feature Filters

Some Feature Filters require parameters to decide whether a feature should be turned on or not. For example, a browser Feature Filter may turn on a feature for a certain set of browsers. It may be desired that Microsoft Edge and Chrome browsers enable a feature, while Firefox doesn't. To do this, a Feature Filter can be designed to expect parameters. These parameters would be specified in the feature configuration and in code, and would be accessible via the `FeatureFilterEvaluationContext` parameter of `evaluate`. `FeatureFilterEvaluationContext` has a property `parameters`, which is a `HashMap<String, Object>`.

### Targeting

Targeting is a feature management strategy that enables developers to progressively rollout new features to their user base. The strategy is built on the concept of targeting a set of users known as the target audience. An audience is made up of specific users, groups, and a designated percentage of the entire user base. The groups that are included in the audience can be broken down further into percentages of their total members.

The following steps demonstrate an example of a progressive rollout for a new 'Beta' feature:

1. Individual users Jeff and Alicia are granted access to the Beta
1. Another user, Mark, asks to opt in and is included.
1. Twenty percent of a group known as "Ring1" users are included in the Beta.
1. The number of "Ring1" users included in the beta is bumped up to 100 percent.
1. Five percent of the user base is included in the beta.
1. The rollout percentage is bumped up to 100 percent and the feature is completely rolled out.

This strategy for rolling out a feature is built into the library through the included `TargetingFilter` Feature Filter.

#### Targeting in an Application

An example web application that uses the targeting Feature Filter is available in the [Example Project](https://github.com/Azure-Samples/azure-spring-boot-samples/tree/main/appconfiguration).

To begin using the `TargetingFilter` in an application, it must be added as a `@Bean` like any other Feature Filter. `TargetingFilter` relies on another `@Bean` to be added to the application, `TargetingContextAccessor`. The `TargetingContextAccessor` allows for defining the current `TargetingContext` to be used for defining the current user ID and groups. An example of this is:

```java
public class MyTargetingContextAccessor implements TargetingContextAccessor {

    @Override
    public void getContextAsync(TargetingContext context) {
        context.setUserId("Jeff");
        ArrayList<String> groups = new ArrayList<String>();
        groups.add("Ring0");
        context.setGroups(groups);
    }

}
```

#### Targeting Evaluation Options

Options are available to customize how targeting evaluation is performed across a given `TargetingFilter`. An optional parameter, `TargetingEvaluationOptions` can be set during `TargetingFilter` creation.

```java
    @Bean
    public TargetingFilter targetingFilter(MyTargetingContextAccessor contextAccessor) {
        return new TargetingFilter(contextAccessor, new TargetingEvaluationOptions().setIgnoreCase(true));
    }
```

## Configuration Refresh

Enabling config refresh for your configurations lets you pull their latest values from your App Configuration store(s) without having to restart the application.

To enable refresh, monitoring needs to be enabled along with monitoring triggers. A monitoring trigger is a key with an optional label that is checked for value change for triggering updates. The value of the monitoring trigger can be any value, as long as it changes when a refresh is needed.

> [!NOTE]
> Any operation that changes the etag of a monitoring trigger will cause a refresh, such as a content-type change.

```yml
spring:
  cloud:
    azure:
      appconfiguration:
        stores:
        - monitoring:
          enabled: true
          triggers:
          - key: [my-watched-key]
            label: [my-watched-label]
```

To trigger a configuration refresh, change the value of a key in your configuration store. Then update one of watch keys to a new value. This triggers the creation of a log. For example, changing the value of `/application/config.message` triggers the log message:

```console
INFO 17496 --- [TaskScheduler-1] o.s.c.e.event.RefreshEventListener       : Refresh keys changed: [config.message]
```

After generating the log, the application will refresh all `@Bean`'s in the refresh scope.

> [!NOTE]
> By default, `@ConfiugrationProperties` annotated beans will be included in this scope.

### Pull Based Refresh

The App Configuration Spring libraries support the ability to periodically check on a refresh interval for changes made to the monitoring triggers. By default the refresh-interval is set to 30 seconds. Once the refresh interval has passed, all triggers are checked in the given store for changes. Any change to the key causes a refresh to trigger. Because the libraries integrate with the Spring refresh system, any refresh will reload all configurations from all stores. The refresh-interval can be set to any interval longer than 1 second. The supported units for the refresh-interval are s, m, h, d for seconds, minutes, hours, and days respectively.

```properties
spring.cloud.azure.appconfiguration.stores[0].monitoring.refresh-interval= 5m
```

#### Automated

When the `spring-cloud-azure-appconfiguration-config-web` library is used, the application automatically checks for refresh whenever a servlet request occurs, specifically `ServletRequestHandledEvent`. The most common way this event is sent, is by requests to endpoints in a `@RestController`.

#### Manual

In applications that only use `spring-cloud-azure-appconfiguration-config`, such as console applications, refresh can be manually triggered. This can be done by calling `AppConfigurationRefresh`'s refreshConfiguration method. `AppConfigurationRefresh` is a `@Bean` that can be injected into any `@Component`.

Also, because the library uses Spring's configuration system, triggering a refresh causes a refresh of all of your configurations, not just reloading the ones from your Azure App Configuration store.

### Push Based Refresh

The `spring-cloud-azure-appconfiguration-config-web` library can be setup to receive push notifications from your Azure App Configuration store to refresh your configuration values. This is done via an Azure Event Grid Web Hook, which can be configured to send notifications of changes to specified keys. By adding the Spring Actuator library as a dependency, you can expose App Configuration's refresh endpoint(s). There are two different endpoints, `appconfiguration-refresh` and `appconfiguration-refresh-bus` these endpoints work similarly to their counterparts `refresh` and `refresh-bus`, where the app configuration endpoints expire the refresh interval instead of forcing a refresh upon receiving. The `refresh` and `refresh-bus` can still be used, but can't be directly connected to Azure Event Grid with a Web Hook as they require a response in setup.

`appconfiguration-refresh` expires the refresh interval, so the remaining refresh interval isn't waited on before the next refresh check. `appconfiguration-refresh-bus` sends a notification to a connected messaging service, such as Azure Service Bus to notify all instances of an application to refresh. In both cases, it doesn't completely expire the refresh interval, but almost does by a small jitter amount. This makes sure not every instance of your application doesn't try to refresh at the same time.

```properties
management.endpoints.web.exposure.include= appconfiguration-refresh, appconfiguration-refresh-bus
```

In addition to exposing the refresh endpoints, a required query parameter has been added for security. No token name or value is set by default, but setting one is required in order to use the endpoints.

```properties
spring.cloud.azure.appconfiguration.stores[0].monitoring.push-notification.primary-token.name=[primary-token-name]
spring.cloud.azure.appconfiguration.stores[0].monitoring.push-notification.primary-token.secret=[primary-token-secret]
spring.cloud.azure.appconfiguration.stores[0].monitoring.push-notification.secondary-token.name=[secondary-token-name]
spring.cloud.azure.appconfiguration.stores[0].monitoring.push-notification.secondary-token.secret=[secondary-token-secret]
```

#### Setting Up Web Hooks

To setup a Web Hook, open your Azure App Configuration store and select the events tab. Select "+ Event Subscription". Set the name of your Event and select the Endpoint type to be Web Hook. Selecting Web Hook causes an Endpoint option to appear, select "Select an endpoint". Your endpoint looks like the following:

```
https://www.myaplication.com/actuator/appconfiguration-refresh?myTokenName=mySecret
```

To "Confirm Selection" sends a setup notification to the given URI and it expects a response. If no response is returned, it fails. The `azure-spring-cloud-appconfiguration-web` library if setup for endpoints returns the correct response if the Azure App Configuration store is configured for the application. This confirmation can be sent in other ways. For more information about Web Hook Delivery, see [Event Grid Web Hook Delivery](/azure/event-grid/webhook-event-delivery) for more information on Web Hook validation.

> [!NOTE]
> This validation only happens on the creation/modification of the endpoint.

It's highly recommended that filters are set up as otherwise a refresh will be triggered after every key creation and modification.

### Forced Client Refresh

The library can be configured to force a refresh of all configurations at a refresh interval.

| Name | Description | Required | Default |
| --- | --- | --- | --- |
| spring.cloud.azure.appconfiguration.refresh-interval | Amount of time, of type Duration, configurations are stored before a check can occur. | No | null |

Refreshing with `spring.cloud.azure.appconfiguration.refresh-interval` doesn't check any configured watch keys. This is used to make sure Key Vault Secrets are kept up to date, as Azure App Configuration can't tell when they're updated.

Since Azure Key Vault stores the public and private key pair of a certificate as a secret, your application can retrieve any certificate as a [Key Vault Reference](#key-vault-references) in App Configuration. Because certificates need to be rotated periodically, client applications need to update just as frequently, which can be done by using the client refresh interval.

### Feature Flag Refresh

If Feature Flags and Monitoring are both enabled, then by default the refresh interval for feature flags is set to 30s. Once the refresh interval has passed, all feature flags are checked in the given store for changes. Any change to the key causes a refresh to trigger. Because the libraries integrate with the Spring refresh system, any refresh will reload all configurations from all stores. The refresh-interval can be set to any interval longer than 1 second. The supported units for the refresh-interval are s, m, h, d for seconds, minutes, hours, and days respectively.

```properties
spring.cloud.azure.appconfiguration.stores[0].monitoring.feature-flag-refresh-interval= 5m
```

## Health Indicator

The client library comes with a Health Indicator that checks whether the connection to the Azure App Configuration store(s) is healthy or not. If enabled for each store, it gives a status of:

- UP - The last connection was successful
- DOWN- The last connection resulted in a non 200 error code. This could be due to a number of issues ranging from credentials expiring to a service issue. The client library will automatically retry to connect to the store at the next refresh-interval.
- NOT LOADED - The config store is listed in the local configuration file, but the config store wasn't loaded from the file at startup. The config store is disabled in the configuration file or the configuration(s) loading failed to load at startup while the `fail-fast` configuration for the store was set to false.

You can enable the Health Indicator by setting `management.health.azure-app-configuration.enabled=true`.

## Client Customization

The App Configuration library uses the [Azure SDK for Java](https://github.com/Azure/azure-sdk-for-java) for connecting to Azure App Configuration and Azure Key Vault. Two interfaces, `ConfigurationClientCustomizer` and `SecretClientCustomizer` are provided to modify the clients. Each interface has a `customize` method that takes in their respective builder along with the `String` value of the URI that the client is being configured for.

```java
public interface ConfigurationClientCustomizer {
    public void setup(ConfigurationClientBuilder builder, String endpoint);
}

public interface SecretClientCustomizer {
    public void setup(SecretClientBuilder builder, String endpoint);
}
```

These interfaces allow for customization of the http client and its configurations, for example, by replacing the default `HttpClient` with another that uses a proxy for all traffic directed to App Configuration and Key Vault.

> [!NOTE]
> The `ConfigurationClientBuilder` and `SecretClientBuilder` are already setup for use when passed into `customize`. Any changes to the clients, including the credentials and retry policy will override those already in place.
>
> This can also be done by using [Spring Cloud Azure configuration](/azure/developer/java/spring-framework/configuration).

```java
public class CustomClient implements ConfigurationClientCustomizer, SecretClientCustomizer {

    @Override
    public void customize(ConfigurationClientBuilder builder, String endpoint) {
        builder.httpClient(buildHttpClient());
    }

    @Override
    public void customize(SecretClientBuilder builder, String endpoint) {
        builder.httpClient(buildHttpClient());
    }

    private HttpClient buildHttpClient() {
        String hostname = System.getProperty("https.proxyHosts");
        String portString = System.getProperty("https.proxyPort");
        int port = Integer.valueOf(portString);

        ProxyOptions proxyOptions = new ProxyOptions(ProxyOptions.Type.HTTP,
                new InetSocketAddress(hostname, port));
        return new NettyAsyncHttpClientBuilder()
                .proxy(proxyOptions)
                .build();
    }

}
```
